<strong>프로세스(process): 실행중인 프로그램</strong><br/><br/>

사용자 이름이 SYSTEM은 시스템이 실행시킨것이다. 
프로그램 : 저장 장치에 파일로 들어있음, 동작을 하지 않는 정적*수동적 개체<br/>
프로세스 : 직접적인 작업을 함, 동작을 하는 능동적 개체<br/>
(윈도우 탐색기로 확인했을때 저장장치에 파일형태로 들어가 있음을 확인할수 있음 , 실행하면 메모리와 cpu등을 할당받음, 작업관리자에서 확인해보면 PID(process id)가 있음 파일이 특히 여러번 실행될경우 파일이름만으로는 관리하기 어려워 process id로 관리함, 상태와 사용자이름으로 누가 실행시켰는지 확인 가능함 // 저장장치에는 명령어에 대한 리스트만 들어가 있지만 프로세스가 되면 메모리사이즈가 더 많이 필요하게 됨  )<br/>

<strong>운영체제로부터 자원을 할당 받아 동작</strong><br/><br/>
자원 : CPU,메모리, 입출력 장치(키보드, 프린터 등), 파일 등<br/>
동작 : CPU가 프로세스의 명령을 실행<br/>
<br/><br/>
<strong>운영체제(프로세스 관리자)가 처리하는 작업</strong><br/><br/>
프로세스를 생성 및 종료<br/>
프로세스를 실행시키기 위한 스케줄링 작업(여러 프로세스를 동작할 수 있기 때문에)<br/>
프로세스의 상태 관리(실행중, 대기중 등 다른상태로 전이 가능하게끔) <br/><br/>

<strong>프로세스의 구성</strong><br/><br/>
- 메모리 구조
- 프로세스 제어 블록  <br/><br/>

<strong>메모리 구조</strong><br/><br/>
프로그램 실행에 직접적으로 필요한 코드와 데이터<br/>
코드영역 + 데이터 영역 <br/>
코드영역 (프로그램 자체 / 코드들이 저장되어 있는 곳 ), 데이터 영역 (프로그램 실행 시 필요한 데이터 ex 상수나 변수의 값, 서브프로그램 호출상태 등)<br/><br/>

데이터영역 세분화
- 정적 데이터 영역 (상수나 전역변수의 값 (프로그램 처음부터 끝까지 관리되어야 하는 값))
- 스택 영역 ( 지역변수, 서브프로그램에 대한정보 )
- 힙 영역 (동적 변수 중에서 사용자가 수동으로 할당하는 것들)<br/><br/>

<strong>프로세스 제어 블록(Process Control Block : PCB)</strong><br/><br/>

- 운영체제가 프로세스를 관리하기 위해 필요한 정보 <br/>
( 프로세스 번호 (PID), 프로세스 상태(동작중 ,대기중 등을 알수 있는), 프로그램 카운터(PC : 다음번호가 가리킬 것이 어디인지 PC값이 알고 있어야 함(명령어의 위치) , 제어의 흐름을 볼 수 있는 곳),레지스터(기본적으로는 CPU에 저장되어 있으나 만약에 잠시 작업이 안끝났는데 다른 곳에 넘겨줘야 할때 PCB에 저장한다.), 메모리 관리 정보( 가상메모리의 매핑 정보), 프로세스 우선 순위(프로세스 스케줄링), 회계정보 등)
<br>
- 각각의 개별 프로세스마다 PCB가 존재 
- 여러 프로세스가 번갈아 실행되는 경우 PCB에 저장된 정보 활용(레지스터)<br><br>


<strong>프로세스 상태 관리</strong><br/>
( 생성, 준비, 실행, 종료, 대기)<br/>
운영체제마다 축약되거나 확대될 수 있음<br/>
생성 - 처음 작업이 시스템에 주어진 상태<br/>
준비 - 실행 준비가 되어 CPU할당을 기다리는 상태(준비Q에 프로세스가 들어와 있는 상태)<br/>
실행 - 프로세스가 처리되는 상태(명령어들을 처리)<br/>
대기 - 프로세스 I/O작업이 끝날때까지 또는 특정 자원을 할당받을 때까지 보류되는 상태 <br/>
종료 - 프로세스가 더 이상 실행되지 않도록 끝난 상태 <br/><br/>

<strong>프로세스 상태 변화</strong><br/>
생성-> 준비 <br/>
디스패치 (준비 -> 실행특정 프로세스에다가 CPU를 할당해주는 과정)( 생성, 준비, 실행, 종료, 대기)<br/>
할당시간 만료 (실행 -> 준비)<br/>
이벤트 대기 (실행 -> 대기: 입출력이나 페이지 변환등 대부분 자의에 의해서)<br/>
재개 조건 만족 (대기 -> 준비)<br/><br/>

<strong>부모 프로세스와 자식 프로세스</strong><br/>
프로세스 생성방법 <br/>
- 사용자가 프로그램을 직접 실행
- 한 프로세스가 다른 프로세스를 생성 (프로세스 생성(시스템 호출)이용)<br/>
부모 프로세스: 시스템 호출을 하는 프로세스 <br/>
자식 프로세스: 시스템 호출을 통해 새로 생성된 프로세스<br/><br/><br/>

<strong>프로세스 생성 시스템 호출</strong><br/>
UNIX, Linux: fork()<br/>
- 자식 프로세스는 부모 프로세스의 복제본(PID만 달라짐, 부모는 자식의 pid를 알 수 있고, 자식의 pid는 0이 됨. pid로 누가 부모 프로세스인지 알 수 있음) <br/> <br/>

UNIX, Linux: exec()<br/>
- 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행
pid=for() <br/>
if(pid==0) <br/>
exec(prg2) <br/>

Windows: CreateProcess()<br/>
- 자식 프로세스는 새로운 프로그램으로 생성<br/><br/>

<strong>프로세스 종료 방법</strong><br/>
프로세스가 모든 처리를 완료(정상정 종료)<br/>
부모 프로세스에 의해 자식 프로세스가 강제 종료<br/>
- 프로세스 종료 시스템 호출 이용
- 자식 프로세스 생성시 얻은 자식 PID 이용
<br/><br/>

부모 프로세스가 종료되는 경우 운영체제가 자식 프로세스 종료<br/><br/>


<strong>쓰레드</strong><br/><br/>
<strong>전통적인 프로세스</strong><br/><br/>
하나의 프로그램을 실행하기 위한 기본적인 단위<br/>
자원 소유의 단위<br/>
- 하나의 메모리 구조<br/>

디스패칭의 단위<br/>
- 하나의 제어 흐름<br/>

프로세스 내에서 다중처리 불가능<br/><br/>

<strong>쓰레드(thread)</strong><br/><br/>
프로세스 내에서의 다중처리를 위해 제안된 개념 <br/>
하나의 프로그램을 실행하기 위한 기본적인 단위<br/>
디스패칭의 단위 : 쓰레드<br/>
(쓰레드마다 pc를 가지고 있음)<br/>
자원소유의 단위: 프로세스 <br/>
전통적인 프로세스 vs 쓰레드 있는 프로세스<br/>
<br/><br/>

<strong>쓰레드(thread)와 프로세스</strong><br/><br/>
쓰레드는 실행에 필요한 최소한의 정보만 가짐 <br/>
- pc를 포함한 레지스터 값
- 상태정보
- 스택 영역 <br/>

<strong>다중 쓰레드로 구성된 프로세스</strong><br/><br/>
멀티 CPU 또는 멀티코어 컴퓨터 시스템<br/>
- 다중 쓰레드를 병렬로 처리 가능(훨씬 효율적인 작업 처리 가능) <br/>

처리 속도 별로 쓰레드가 나눠진 경우<br/>
- 효율적인 처리 기능 <br/>




